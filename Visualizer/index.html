<!DOCTYPE html>
<html lang="en">

<head>
    <title>OpenDRIVE Visualizer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        table {
            border-spacing: 0.5em 0;
        }

        .popup_info {
            text-align: left;
            font-family: monospace;
            display: block;
            color: whitesmoke;
        }

        .bottom_info {
            position: absolute;
            bottom: 1em;
            left: 1em;
            text-align: left;
            font-family: monospace;
            display: block;
            color: whitesmoke;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.css">
</head>

<body>
    <div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
    <div class="bottom_info" id="spotlight_info"></div>

    <input id="xodr_file_input" type="file" style="visibility:hidden" onchange="on_file_select(this.files[0])" />

    <script src="./libOpenDrive.js"></script>
    <script src="./utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.js"></script>

    <script>
        var spotlight_info = document.getElementById('spotlight_info');

        var PARAMS = {
            load_file: () => { document.getElementById('xodr_file_input').click(); },
            detail: 0.3,
            resolution: 0.3,
            ref_line: true,
            geom_edges: false,
            wireframe: false,
            spotlight: true,
            fitView: () => { fitView(ref_line_group); },
            lateralProfile: true,
            laneHeight: true,
            reload_map: () => { reload_odr_map(); },
        };

        var COLORS = {
            road: 0xaeaeae,
            outline: 0xae52d4,
            ref_line: 0xffffff,
            background: 0x111215,
            lane_highlight: 0x0288d1,
            road_highlight: 0x9A9A9A,
        };

        const notyf = new Notyf({
            duration: 3000,
            position: { x: 'right', y: 'bottom' },
            types: [
                {
                    type: 'info',
                    background: '#607d8b',
                    icon: false
                }
            ]
        });

        var scene = new THREE.Scene();
        scene.background = new THREE.Color(COLORS.background);
        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('ThreeJS').appendChild(renderer.domElement);

        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000);
        camera.lookAt(0, 0, 0);
        camera.up.set(0, 0, 1); /* Coordinate system with Z pointing up */

        var controls = new THREE.MapControls(camera, renderer.domElement);
        controls.addEventListener('change', () => { renderer.render(scene, camera) });

        var ref_line_group = new THREE.Group();
        ref_line_group.renderOrder = 3;
        var outline_group = new THREE.Group();
        outline_group.renderOrder = 2;
        var roadmark_group = new THREE.Group();
        roadmark_group.renderOrder = 1;
        var road_mesh_group = new THREE.Group();
        var basic_groups = [ref_line_group, outline_group, roadmark_group, road_mesh_group];
        scene.add(...basic_groups);

        var odr_geom_edges_group = new THREE.Group();
        var lazy_loaded_groups = [odr_geom_edges_group];
        scene.add(...lazy_loaded_groups);

        var disposable_objs = [];

        var mouse = new THREE.Vector2();
        var INTERSECTED;
        var raycaster = new THREE.Raycaster();
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('mousemove', onDocumentMouseMove, false);
        window.addEventListener('dblclick', onDocumentMouseDbClick, false);

        renderer.render(scene, camera);

        var gui = new dat.GUI();
        gui.add(PARAMS, 'load_file').name('ðŸ“ Load .xodr');
        gui.add(PARAMS, 'detail', { Low: 1.0, Medium: 0.3, High: 0.03 }).name('ðŸ“  Detail').onChange((val) => {
            PARAMS.resolution = Number(PARAMS.detail);
            console.log(PARAMS.resolution);
            load_odr_map(true, false);
        });
        gui.add(PARAMS, 'spotlight').name("ðŸ”¦ Spotlight").onChange((val) => {
        });
        gui.add(PARAMS, 'fitView').name("âŸ² Reset Camera");
        var gui_show_folder = gui.addFolder('View');
        gui_show_folder.add(PARAMS, 'ref_line').name("Reference Line").onChange((val) => {
            ref_line_group.visible = val;
            renderer.render(scene, camera);
        });
        gui_show_folder.add(PARAMS, 'wireframe').name("Wireframe").onChange((val) => {
            road_mesh_group.traverse(n => {
                if (n.material) {
                    n.material.wireframe = val;
                    n.material.transparent = !val;
                    n.material.color.set(COLORS.road);
                }
            });
            renderer.render(scene, camera);
        });
        gui_show_folder.add(PARAMS, 'geom_edges').name("Geometry Edges").onChange((val) => {
            if (odr_geom_edges_group.children.length == 0)
                add_odr_geom_edges();
            odr_geom_edges_group.visible = val;
            renderer.render(scene, camera);
        });
        var attributes_folder = gui.addFolder('Load Attributes');
        attributes_folder.add(PARAMS, 'lateralProfile').name("Lateral Profile");
        attributes_folder.add(PARAMS, 'laneHeight').name("Lane Height");
        attributes_folder.add(PARAMS, 'reload_map').name("Reload Map");

        var ModuleOpenDrive = null;
        var OpenDriveMap = null;
        libOpenDrive().then(Module => {
            ModuleOpenDrive = Module;
            fetch("./eva.xodr").then((file_data) => {
                file_data.text().then((file_text) => {
                    file_load(file_text, false);
                });
            });
        });

        function file_load(file_text, clear_map) {
            if (clear_map)
                ModuleOpenDrive['FS_unlink']('./data.xodr');
            ModuleOpenDrive['FS_createDataFile'](".", "data.xodr", file_text, true, true);
            OpenDriveMap = new ModuleOpenDrive.OpenDriveMap("./data.xodr", PARAMS.lateralProfile, PARAMS.laneHeight);
            load_odr_map(clear_map);
        }

        function on_file_select(file) {
            let file_reader = new FileReader();
            file_reader.onload = () => {
                file_load(file_reader.result, true);
            }
            file_reader.readAsText(file);
        }

        function reload_odr_map() {
            OpenDriveMap = new ModuleOpenDrive.OpenDriveMap("./data.xodr", PARAMS.lateralProfile, PARAMS.laneHeight);
            load_odr_map(true, false);
        }

        function load_odr_map(clear_map = true, fit_view = true) {
            if (clear_map) {
                for (let group of basic_groups)
                    group.remove(...group.children);
                for (let group of lazy_loaded_groups)
                    group.remove(...group.children);
                for (let obj of disposable_objs)
                    obj.dispose();
            }

            const t0 = performance.now();
            const odr_roads = OpenDriveMap.roads;

            for (let [road_id, road] of get_std_map_entries(odr_roads)) {
                /* ref line */
                let refl_verts = read_std_vec_vertices(road.ref_line.get_line(0.0, road.length, PARAMS.resolution, false), true);
                const refline_line = add_line(refl_verts, COLORS.ref_line);
                refline_line.material.depthTest = false;
                ref_line_group.add(refline_line);
                disposable_objs.push(refline_line.geometry, refline_line.material);
            }

            if (fit_view)
                fitView(ref_line_group);

            for (const [road_id, road] of get_std_map_entries(odr_roads)) {
                let road_group = new THREE.Group();
                for (const [s0, lanesec] of get_std_map_entries(road.s_to_lanesection)) {

                    let lane_sec_group = new THREE.Group();
                    for (const [lane_id, lane] of get_std_map_entries(lanesec.id_to_lane)) {
                        /* lane mesh */
                        const raw_lane_mesh = lane.get_mesh(lanesec.s0, lanesec.get_end(), PARAMS.resolution, false);
                        const lane_mesh_vertices = read_std_vec_vertices(raw_lane_mesh.vertices, true);

                        const lane_geom = new THREE.BufferGeometry();
                        lane_geom.setAttribute('position', new THREE.BufferAttribute(lane_mesh_vertices, 3));
                        const lane_mesh_indices = get_std_vec_entries(raw_lane_mesh.indices, true, Uint32Array);
                        lane_geom.setIndex(new THREE.BufferAttribute(lane_mesh_indices, 1));
                        const lane_material = new THREE.MeshBasicMaterial({ color: COLORS.road, wireframe: PARAMS.wireframe, transparent: !PARAMS.wireframe, opacity: 0.3, visible: true });
                        const lane_mesh = new THREE.Mesh(lane_geom, lane_material);
                        lane_mesh.matrixAutoUpdate = false;
                        disposable_objs.push(lane_geom, lane_material);
                        lane_sec_group.add(lane_mesh);

                        lane_mesh.userData = {
                            road_id, lansection_s0: s0, lane_id, lane_type: lane.type, road, lane_sec_group, road_group
                        };

                        /* lane outline */
                        const lane_outline_line = add_line(lane_mesh_vertices, COLORS.outline);
                        lane_outline_line.matrixAutoUpdate = false;
                        disposable_objs.push(lane_outline_line.geometry, lane_outline_line.material);
                        outline_group.add(lane_outline_line);
                    }

                    road_group.add(lane_sec_group);
                }
                road_mesh_group.add(road_group);
            }

            const t1 = performance.now();
            console.log("Heap size: " + ModuleOpenDrive.HEAP8.length / 1024 / 1024 + " mb");

            if (PARAMS.geom_edges && (odr_geom_edges_group.children.length == 0))
                add_odr_geom_edges();

            renderer.render(scene, camera);
            spotlight_info.style.display = "none";
            animate();

            const info_msg = `
                <div class=popup_info>
                <h3>Finished loading</h3>
                <table>
                    <tr><th>Time</th><th>${((t1 - t0) / 1e3).toFixed(2)}s</th></tr>
                    <tr><th>Num Roads</th><th>${odr_roads.size()}</th></tr>
                    <tr><th>Num Vertices</th><th>${renderer.info.render.triangles}</th></tr>
                </table>
                </div>`;
            notyf.open({ type: 'info', message: info_msg });
        }

        function animate() {
            requestAnimationFrame(animate);
            if (PARAMS.spotlight) {
                update();
            }
        }

        function update() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([road_mesh_group], true);
            if (intersects.length > 0) {
                if (INTERSECTED != intersects[0].object) {
                    if (INTERSECTED) {
                        INTERSECTED.userData.road_group.traverse(n => { if (n.material) { n.material.color.set(COLORS.road); n.material.opacity = 0.3; } });
                    }
                    INTERSECTED = intersects[0].object;
                    spotlight_info.style.display = "block";
                    INTERSECTED.userData.road_group.traverse(n => { if (n.material) { n.material.color.set(COLORS.road_highlight); } });
                    INTERSECTED.material.color.set(COLORS.lane_highlight);
                    INTERSECTED.material.opacity = 0.8;
                    renderer.render(scene, camera);
                }
            } else {
                if (INTERSECTED) {
                    INTERSECTED.userData.road_group.traverse(n => { if (n.material) { n.material.color.set(COLORS.road); n.material.opacity = 0.3; } });
                    renderer.render(scene, camera);
                }
                INTERSECTED = null;
                spotlight_info.style.display = "none";
            }

            if (INTERSECTED) {
                const userData = INTERSECTED.userData;
                const intersec_pt = intersects[0].point;

                /* project interesected point onto reference line */
                const s_proj = userData.road.ref_line.match(intersec_pt.x, intersec_pt.y);
                const refl_pt = userData.road.ref_line.get_xyz(s_proj);

                const grad_vec = userData.road.ref_line.get_grad(s_proj);
                const dist = Math.sqrt(Math.pow(intersec_pt.x - refl_pt[0], 2) + Math.pow(intersec_pt.y - refl_pt[1], 2) + Math.pow(intersec_pt.z - refl_pt[2], 2));
                const t_offs = Math.sign(grad_vec[0] * (intersec_pt.y - refl_pt[1]) - grad_vec[1] * (intersec_pt.x - refl_pt[0])) * dist;

                spotlight_info.innerHTML = `
                        <table>
                            <tr><th>road id</th><th>${userData.road_id}</th></tr>
                            <tr><th>section s0</th><th>${userData.lansection_s0.toFixed(2)}</th></tr>
                            <tr><th>lane</th><th>${userData.lane_id} <span style="color:gray;">${userData.lane_type}</span></th></tr>
                            <tr><th>s/t</th><th>[${s_proj.toFixed(2)}, ${t_offs.toFixed(2)}]</th>
                            <tr><th>world</th><th>[${intersec_pt.x.toFixed(2)}, ${intersec_pt.y.toFixed(2)}, ${intersec_pt.z.toFixed(2)}]</th></tr>
                        </table>`;
            }
        }

        function add_line(vertices, color) {
            const line_geom = new THREE.BufferGeometry();
            line_geom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            const line_material = new THREE.LineBasicMaterial({ color: color });
            const line_line = new THREE.Line(line_geom, line_material);
            return line_line;
        }

        function add_odr_geom_edges() {
            const side_len = 1.0;
            const world_vec = new THREE.Vector3(0, 0, side_len);
            for (const [road_id, road] of get_std_map_entries(OpenDriveMap.roads)) {
                for (const [s0, odr_geom] of get_std_map_entries(road.ref_line.s0_to_geometry)) {
                    const pt0 = new THREE.Vector3(...odr_geom.get_xy(odr_geom.s0), road.ref_line.elevation_profile.get(odr_geom.s0));
                    let u_vec = new THREE.Vector3(...odr_geom.get_grad(odr_geom.s0), road.ref_line.elevation_profile.get_grad(odr_geom.s0));
                    u_vec.normalize().cross(world_vec).multiplyScalar(side_len);

                    /* edge plane corner points */
                    const c1 = (pt0.clone().add(u_vec)).add(world_vec);
                    const c2 = (pt0.clone().add(u_vec)).sub(world_vec);
                    const c3 = (pt0.clone().sub(u_vec)).add(world_vec);
                    const c4 = (pt0.clone().sub(u_vec)).sub(world_vec);

                    let geom = new THREE.BufferGeometry().setFromPoints([pt0, c1, c2, c3, c4]);
                    geom.setIndex([0, 1, 2, 0, 2, 4, 0, 4, 3, 0, 3, 1]);
                    let material = new THREE.MeshBasicMaterial({ color: COLORS.ref_line, side: THREE.DoubleSide, transparent: true, opacity: 0.4 });
                    let mesh = new THREE.Mesh(geom, material);
                    odr_geom_edges_group.add(mesh);
                }
            }
        }

        function fitView(obj) {
            const bbox = new THREE.Box3().setFromObject(obj);
            let center_pt = new THREE.Vector3();
            bbox.getCenter(center_pt);

            const l2xy = 0.5 * Math.sqrt(Math.pow(bbox.max.x - bbox.min.x, 2.0) + Math.pow(bbox.max.y - bbox.min.y, 2));
            const fov2r = (camera.fov * 0.5) * (Math.PI / 180.0);
            const dz = l2xy / Math.tan(fov2r);

            camera.position.set(center_pt.x, center_pt.y, bbox.max.z + dz);
            controls.target.set(center_pt.x, center_pt.y, center_pt.z);
            controls.update();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        function onDocumentMouseDbClick(event) {
            if (INTERSECTED)
                fitView(INTERSECTED);
        }
    </script>
</body>

</html>