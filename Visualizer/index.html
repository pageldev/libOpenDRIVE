<!DOCTYPE html>
<html lang="en">

<head>
    <title>OpenDRIVE Visualizer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        table {
            border-spacing: 0.5em 0;
        }

        .popup_info {
            text-align: left;
            font-family: monospace;
            display: block;
            color: whitesmoke;
        }

        .bottom_info {
            position: absolute;
            bottom: 1em;
            left: 1em;
            text-align: left;
            font-family: monospace;
            display: block;
            color: whitesmoke;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.css">
</head>

<body>
    <div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
    <div class="bottom_info" id="spotlight_info"></div>

    <input id="xodr_file_input" type="file" style="visibility:hidden" onchange="on_file_select(this.files[0])" />

    <script src="./libOpenDrive.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.115.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.js"></script>

    <script type="x-shader/x-vertex" id="vertexShader">
        varying vec3 vWorldPosition;

        void main() {
            vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
            vWorldPosition = worldPosition.xyz;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">
        vec3 topColor = vec3(0.62, 0.62, 0.62);
        vec3 bottomColor = vec3(0.90, 0.90, 0.90);

        varying vec3 vWorldPosition;
        void main() {
            float h = normalize(vWorldPosition).z;
            gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0 ), 0.8 ), 0.0 ) ), 1.0 );
        }
    </script>

    <script>
        const vertexShader = document.getElementById('vertexShader').textContent;
        const fragmentShader = document.getElementById('fragmentShader').textContent;

        var PARAMS = {
            load_file: () => { document.getElementById('xodr_file_input').click(); },
            resolution: 0.3,
            ref_line: true,
            wireframe: false,
            spotlight: true,
            fitView: () => { fitView(refline_lines); },
            lateralProfile: true,
            laneHeight: true,
            reload_map: () => { reload_odr_map(); },
            selected_road_id: null,
        };

        var COLORS = {
            road: 0.68,
            outline: 0x757575,
            ref_line: 0x69f0ae,
            background: 0x444444,
            lane_highlight: 0x0288d1,
            road_highlight: 0x9A9A9A,
            outline_highlight: 0xc158dc,
        };

        const refline_material = new THREE.LineBasicMaterial({ color: COLORS.ref_line });
        const outlines_material = new THREE.LineBasicMaterial({ color: COLORS.outline });
        const picking_material = new THREE.MeshBasicMaterial({ vertexColors: true });
        const road_network_material = new THREE.MeshPhongMaterial({
            vertexColors: THREE.VertexColors,
            wireframe: PARAMS.wireframe,
            polygonOffset: true,
            polygonOffsetFactor: 20,
            polygonOffsetUnits: 1,
            shininess: 15,
            flatShading: true
        });
        const sky_material = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            side: THREE.BackSide
        });
    </script>

    <script>
        var INTERSECTED = 0xffffff;
        var disposable_objs = [];
        var mouse = new THREE.Vector2();

        var refline_lines = null;
        var road_network_mesh = null;
        var lane_outline_lines = null;
        var sky_dome = null;

        var spotlight_info = document.getElementById('spotlight_info');
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('mousemove', onDocumentMouseMove, false);
        window.addEventListener('dblclick', onDocumentMouseDbClick, false);

        const notyf = new Notyf({
            duration: 3000,
            position: { x: 'right', y: 'bottom' },
            types: [{ type: 'info', background: '#607d8b', icon: false }]
        });

        const scene = new THREE.Scene();
        const renderer = new THREE.WebGLRenderer({ antialias: true, sortObjects: false });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('ThreeJS').appendChild(renderer.domElement);

        const picking_scene = new THREE.Scene();
        picking_scene.background = new THREE.Color(0xffffff);
        const picking_texture = new THREE.WebGLRenderTarget(1, 1);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000);
        camera.up.set(0, 0, 1); /* Coordinate system with Z pointing up */

        const controls = new THREE.MapControls(camera, renderer.domElement);
        controls.addEventListener('change', () => { renderer.render(scene, camera) });

        const light = new THREE.DirectionalLight(0xffffff);
        light.position.set(0, 0, 1);
        light.castShadow = true;
        scene.add(light);

        renderer.render(scene, camera);

        const gui = new dat.GUI();
        gui.add(PARAMS, 'load_file').name('ðŸ“ Load .xodr');
        gui.add(PARAMS, 'resolution', { Low: 1.0, Medium: 0.3, High: 0.02 }).name('ðŸ“  Detail').onChange((val) => { load_odr_map(true, false); });
        gui.add(PARAMS, 'spotlight').name("ðŸ”¦ Spotlight");
        gui.add(PARAMS, 'fitView').name("âŸ² Reset Camera");

        var gui_view_folder = gui.addFolder('View');
        gui_view_folder.add(PARAMS, 'ref_line').name("Reference Line").onChange((val) => {
            refline_lines.visible = val;
            renderer.render(scene, camera);
        });
        gui_view_folder.add(PARAMS, 'wireframe').name("Wireframe").onChange((val) => {
            light.intensity = Number(!val);
            road_network_mesh.material.wireframe = val;
            renderer.render(scene, camera);
        });

        var gui_attributes_folder = gui.addFolder('Load Attributes');
        gui_attributes_folder.add(PARAMS, 'lateralProfile').name("Lateral Profile");
        gui_attributes_folder.add(PARAMS, 'laneHeight').name("Lane Height");
        gui_attributes_folder.add(PARAMS, 'reload_map').name("Reload Map");

        var ModuleOpenDrive = null;
        var OpenDriveMap = null;
        libOpenDrive().then(Module => {
            ModuleOpenDrive = Module;
            fetch("./eva.xodr").then((file_data) => {
                file_data.text().then((file_text) => {
                    file_load(file_text, false);
                });
            });
        });

        function file_load(file_text, clear_map) {
            if (clear_map)
                ModuleOpenDrive['FS_unlink']('./data.xodr');
            ModuleOpenDrive['FS_createDataFile'](".", "data.xodr", file_text, true, true);
            OpenDriveMap = new ModuleOpenDrive.OpenDriveMap("./data.xodr", PARAMS.lateralProfile, PARAMS.laneHeight);
            load_odr_map(clear_map);
        }

        function on_file_select(file) {
            let file_reader = new FileReader();
            file_reader.onload = () => { file_load(file_reader.result, true); }
            file_reader.readAsText(file);
        }

        function reload_odr_map() {
            OpenDriveMap = new ModuleOpenDrive.OpenDriveMap("./data.xodr", PARAMS.lateralProfile, PARAMS.laneHeight);
            load_odr_map(true, false);
        }

        function load_odr_map(clear_map = true, fit_view = true) {
            const t0 = performance.now();
            if (clear_map) {
                scene.remove(road_network_mesh, refline_lines, lane_outline_lines, sky_dome);
                picking_scene.remove(...picking_scene.children);
                for (let obj of disposable_objs)
                    obj.dispose();
            }

            const odr_roads = OpenDriveMap.roads;

            /* reflines */
            const reflines_geom = new THREE.BufferGeometry();
            const odr_refline_segments = OpenDriveMap.get_refline_segments(PARAMS.resolution);
            reflines_geom.setAttribute('position', new THREE.Float32BufferAttribute(get_std_vec_entries(odr_refline_segments.vertices).flat(), 3));
            reflines_geom.setIndex(get_std_vec_entries(odr_refline_segments.indices, true));
            refline_lines = new THREE.LineSegments(reflines_geom, refline_material);
            refline_lines.renderOrder = 10;
            disposable_objs.push(reflines_geom);
            scene.add(refline_lines);

            /* road network mesh */
            const road_network_geom = new THREE.BufferGeometry();
            const odr_road_network_mesh = OpenDriveMap.get_mesh(PARAMS.resolution);
            road_network_geom.setAttribute('position', new THREE.Float32BufferAttribute(get_std_vec_entries(odr_road_network_mesh.vertices, true).flat(), 3));
            road_network_geom.setAttribute('color', new THREE.Float32BufferAttribute(new Float32Array(road_network_geom.attributes.position.count * 3), 3));
            road_network_geom.attributes.color.array.fill(COLORS.road);
            road_network_geom.setIndex(get_std_vec_entries(odr_road_network_mesh.indices, true));
            road_network_mesh = new THREE.Mesh(road_network_geom, road_network_material);
            road_network_mesh.renderOrder = 0;
            road_network_mesh.receiveShadow = true;
            road_network_mesh.userData = { odr_road_network_mesh };
            disposable_objs.push(road_network_geom);
            scene.add(road_network_mesh);

            /* lane outline */
            const outlines_geom = new THREE.BufferGeometry();
            outlines_geom.setAttribute('position', road_network_geom.attributes.position);
            outlines_geom.setIndex(get_std_vec_entries(odr_road_network_mesh.get_lane_outline_indices(), true));
            lane_outline_lines = new THREE.LineSegments(outlines_geom, outlines_material);
            lane_outline_lines.renderOrder = 9;
            scene.add(lane_outline_lines);

            /* picking road network mesh */
            /* based on examples/webgl_interactive_cubes_gpu.html */
            /* give the geometry's vertices a color corresponding to the "id" = vertex start idx of lane submesh */
            const picking_road_network_geom = road_network_geom.clone();
            const picking_color = new THREE.Color();
            for (const [vert_idx, lane_id] of get_std_map_entries(odr_road_network_mesh.lane_start_indices)) {
                picking_color.setHex(vert_idx);
                const vert_idx_interval = odr_road_network_mesh.get_idx_interval_lane(vert_idx);
                const vert_count = vert_idx_interval[1] - vert_idx_interval[0];
                applyVertexColors(picking_road_network_geom.attributes.color, picking_color, vert_idx_interval[0], vert_count);
            }
            const picking_mesh = new THREE.Mesh(picking_road_network_geom, picking_material);
            disposable_objs.push(picking_road_network_geom);
            picking_scene.add(picking_mesh);

            /* sky dome */
            const bbox_reflines = new THREE.Box3().setFromObject(refline_lines);
            const bbox_center_pt = new THREE.Vector3();
            bbox_reflines.getCenter(bbox_center_pt);
            const dome_radius = Math.max(bbox_reflines.min.distanceTo(bbox_reflines.max) * 3, 800);
            const sky_geom = new THREE.SphereGeometry(dome_radius, 32, 15);
            sky_dome = new THREE.Mesh(sky_geom, sky_material);
            sky_dome.position.set(bbox_center_pt.x, bbox_center_pt.y, bbox_center_pt.z);
            disposable_objs.push(sky_geom);
            scene.add(sky_dome);

            if (fit_view)
                fitView(refline_lines);

            renderer.render(scene, camera);

            const t1 = performance.now();
            console.log("Heap size: " + ModuleOpenDrive.HEAP8.length / 1024 / 1024 + " mb");
            const info_msg = `
                <div class=popup_info>
                <h3>Finished loading</h3>
                <table>
                    <tr><th>Time</th><th>${((t1 - t0) / 1e3).toFixed(2)}s</th></tr>
                    <tr><th>Num Roads</th><th>${odr_roads.size()}</th></tr>
                    <tr><th>Num Vertices</th><th>${renderer.info.render.triangles}</th></tr>
                </table>
                </div>`;
            notyf.open({ type: 'info', message: info_msg });

            spotlight_info.style.display = "none";
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);

            if (PARAMS.spotlight) {
                controls.update();
                camera.setViewOffset(renderer.domElement.width, renderer.domElement.height, mouse.x * window.devicePixelRatio | 0, mouse.y * window.devicePixelRatio | 0, 1, 1);
                renderer.setRenderTarget(picking_texture);
                renderer.render(picking_scene, camera);
                camera.clearViewOffset();

                const pixel_buffer = new Uint8Array(4);
                renderer.readRenderTargetPixels(picking_texture, 0, 0, 1, 1, pixel_buffer);
                const picked_id = (pixel_buffer[0] << 16) | (pixel_buffer[1] << 8) | (pixel_buffer[2]); // interpret the pixel as an ID
                renderer.setRenderTarget(null);

                if (picked_id != 0xffffff) {
                    if (INTERSECTED != picked_id) {
                        if (INTERSECTED != 0xffffff) {
                            const prev_lane_vert_idx_interval = road_network_mesh.userData.odr_road_network_mesh.get_idx_interval_lane(INTERSECTED);
                            road_network_mesh.geometry.attributes.color.array.fill(COLORS.road, prev_lane_vert_idx_interval[0] * 3, prev_lane_vert_idx_interval[1] * 3);
                        }
                        INTERSECTED = picked_id;
                        const lane_vert_idx_interval = road_network_mesh.userData.odr_road_network_mesh.get_idx_interval_lane(INTERSECTED);
                        const vert_count = (lane_vert_idx_interval[1] - lane_vert_idx_interval[0]);
                        applyVertexColors(road_network_mesh.geometry.attributes.color, new THREE.Color(COLORS.lane_highlight), lane_vert_idx_interval[0], vert_count);
                        road_network_mesh.geometry.attributes.color.needsUpdate = true;
                        renderer.render(scene, camera);
                    }
                } else {
                    if (INTERSECTED != 0xffffff) {
                        const lane_vert_idx_interval = road_network_mesh.userData.odr_road_network_mesh.get_idx_interval_lane(INTERSECTED);
                        road_network_mesh.geometry.attributes.color.array.fill(COLORS.road, lane_vert_idx_interval[0] * 3, lane_vert_idx_interval[1] * 3);
                        road_network_mesh.geometry.attributes.color.needsUpdate = true;
                        renderer.render(scene, camera);
                    }
                    INTERSECTED = 0xffffff;
                }
            }
        }

        function fitView(obj) {
            const bbox = new THREE.Box3().setFromObject(obj);
            let center_pt = new THREE.Vector3();
            bbox.getCenter(center_pt);

            const l2xy = 0.5 * Math.sqrt(Math.pow(bbox.max.x - bbox.min.x, 2.0) + Math.pow(bbox.max.y - bbox.min.y, 2));
            const fov2r = (camera.fov * 0.5) * (Math.PI / 180.0);
            const dz = l2xy / Math.tan(fov2r);

            camera.position.set(center_pt.x, center_pt.y, bbox.max.z + dz);
            controls.target.set(center_pt.x, center_pt.y, center_pt.z);
            controls.maxDistance = center_pt.distanceTo(bbox.max) * 2.0;
            controls.update();

            renderer.render(scene, camera);
        }

        function applyVertexColors(buffer_attribute, color, offset, count) {
            const colors = new Float32Array(count * buffer_attribute.itemSize);
            for (let i = 0; i < (count * buffer_attribute.itemSize); i += buffer_attribute.itemSize) {
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }
            buffer_attribute.array.set(colors, offset * buffer_attribute.itemSize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentMouseMove(event) {
            event.preventDefault();
            mouse.x = event.clientX;
            mouse.y = event.clientY;
        }

        function onDocumentMouseDbClick(event) {
        }

        function get_std_map_keys(std_map, delete_map = false) {
            let map_keys = [];
            const map_keys_vec = std_map.keys();
            for (let idx = 0; idx < map_keys_vec.size(); idx++)
                map_keys.push(map_keys_vec.get(idx));
            map_keys_vec.delete();
            if (delete_map)
                std_map.delete();
            return map_keys;
        }

        function get_std_map_entries(std_map) {
            let map_entries = [];
            for (let key of get_std_map_keys(std_map))
                map_entries.push([key, std_map.get(key)]);
            return map_entries;
        }

        function get_std_vec_entries(std_vec, delete_vec = false, ArrayType = null) {
            let entries = ArrayType ? new ArrayType(std_vec.size()) : new Array(std_vec.size());
            for (let idx = 0; idx < std_vec.size(); idx++)
                entries[idx] = std_vec.get(idx);
            if (delete_vec)
                std_vec.delete();
            return entries;
        }
    </script>
</body>

</html>